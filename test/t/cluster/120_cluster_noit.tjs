name = "clustered noit"
plan = 39

'use strict';
var tools = require('./testconfig'),
    nc = require('../../src/js/noit/index'),
    fs = require('fs'),
    async = require('async');

var global_seq = 12928734;

var expected_comms = 
  { '0x50555420': { name: 'mtev_wire_rest_api', version: '1.0' },
    '0x47455420': { name: 'mtev_wire_rest_api', version: '1.0' },
    '0x48454144': { name: 'mtev_wire_rest_api', version: '1.0' },
    '0xda7afeed': { name: 'log_transit', version: '1.0' },
    '0x44454c45': { name: 'mtev_wire_rest_api', version: '1.0' },
    '0x7e66feed': { name: 'log_transit', version: '1.0' },
    '0x52455645': { name: 'reverse_socket_accept' },
    '0x504f5354': { name: 'mtev_wire_rest_api', version: '1.0' },
    '0xfa57feed': { name: 'livestream_transit', version: '1.0' },
    '0x43415041': { name: 'capabilities_transit', version: '1.0' },
    '0x4d455247': { name: 'mtev_wire_rest_api', version: '1.0' } };

var noit, conn;

function check_caps(conn, test, noit, callback) {
  var reqtime = Date.now();
  conn.request({ path: '/capa.json' }, function(code,data) {
    var caps = {}, restime = Date.now();
    try { caps = JSON.parse(data); } catch(e) {}

    test.like(caps.current_time, /^\d+$/, 'current_time is a number');
    var reqdur = restime - reqtime;
    var remote_time = parseInt(caps.current_time) + reqdur/2.0;
    var time_error = Math.abs(remote_time - restime);
    test.ok(time_error < reqdur, 'time skew check')

    for (var p in caps.services) {
      if(caps.services[p].control_dispatch == 'control_dispatch') {
        var comms = caps.services[p].commands;
        test.is_deeply(comms, expected_comms, "capabilities");
        return callback();
      }
    }
    callback();
  });
}

function check_show(conn, uuid, cb) {
  conn.request({path: '/checks/show/' + uuid + '.json'}, cb);
}

function check_delete(conn, uuid, cb) {
  conn.request({method: 'DELETE', path: '/checks/delete/' + uuid}, cb);
}

function put_check(conn, uuid, name, cb) {
  var seq = 0;
  var module = 'selfcheck';
  if(cb == null) {
    cb = name;
    name = "selfcheck";
  }
  if(name != "selfcheck") {
    module = "ping_icmp";
    seq = global_seq++;
  }
  conn.request({path: '/checks/set/' + uuid, method: 'PUT' },
    '<?xml version="1.0" encoding="utf8"?>' +
    '<check>' +
    '<attributes>' +
    '  <target>127.0.0.1</target>' +
    '  <period>1000</period>' +
    '  <timeout>500</timeout>' +
    '  <name>' + name + '</name>' +
    '  <filterset>allowall</filterset>' +
    '  <module>' + module + '</module>' +
    '  <seq>' + seq + '</seq>' +
    '</attributes>' +
    '<config/>' +
    '</check>',
    cb);
}

function put_cluster(conn, nodes, idx, cb) {
  var payload = '<?xml version="1.0" encoding="utf8"?>' +
    '<cluster name="noit" port="' + nodes[idx].port + '" period="200" timeout="1000" maturity="2000" key="shame_on_me" seq="1">';
  for(var i=0; i<nodes.length; i++) {
    payload = payload + '<node id="' + nodes[i].id +'" cn="noit-test" address="127.0.0.1" port="' + nodes[i].port + '"/>';
  }
  payload = payload + ' </cluster>';
  conn.request({path: '/cluster', method: 'POST' }, payload, cb);
}

function spinup_selfcheck(conn, test, noit, uuid) {
 return [
      function(callback) {
        check_show(conn, uuid, function(code, data) {
          test.is(code, 404, 'show check absent');
          callback();
        })
      },
      function(callback) {
        put_check(conn, uuid, function(code, data) {
          test.is(code, 200, 'put check');
          callback();
        })
      },
      function(done) { noit.wait_for_log(/`selfcheck <-/, 20000, function() {done();}) },
      function(callback) {
        check_show(conn, uuid, function(code, data) {
          test.is(code, 200, 'show check absent');
          try {
            var json = JSON.parse(data);
            test.is(json.status.good, true, 'show check run');
          }
          catch(e) { test.fail('show check run'); }
          callback();
        })
      }
  ];
}

function check_check(test, conn, uuid, expect_code, key, value, callback) {
  if(callback == null) {
    callback = value;
    value = null;
  }
  if(callback == null) {
    callback = key;
    key = null;
  }
  check_show(conn, uuid, function(code, json) {
    var data = {}
    test.is(code, expect_code, 'check check: ('+expect_code+')');
    if(key) {
      try { data = JSON.parse(json); } catch(e) {}
      if(typeof(key) === 'function') {
        key(test, data);
      } else {
        if(!Array.isArray(key)) key = [key];
        var obj = data;
        for(var i=0; i<key.length; i++) if(obj != null) obj = obj[key[i]];
        test.is(obj, value, 'check check: ' + key + '=' + value);
      }
    }
    callback();
  })
}

test = function() {
  var test = this;
  noit1 = new tools.noit(test, "120a", { 'logs_debug': { '': 'false' } });
  noit2 = new tools.noit(test, "120b", { 'logs_debug': { '': 'false' } });
  selfcheck1 = '5a74f6f2-3125-44de-84e7-6ea7275e5fee';
  selfcheck2 = 'ab419eda-6f51-466f-b086-63ae940c8147';
  check = '39568546-da44-465e-abd8-a348a27b2fd5';
  conn1 = noit1.get_connection();
  conn2 = noit2.get_connection();
  var running = 0;
  var complete = function() {
    if(running < 2) return;
    async.series([
      function(callback) { check_caps(conn1, test, noit1, callback); },
      function(callback) {
        var fns = spinup_selfcheck(conn1, test, noit1, selfcheck1);
        fns.push(function() { callback(); });
        async.series(fns);
      },
      function(callback) {
        var fns = spinup_selfcheck(conn2, test, noit2, selfcheck2);
        fns.push(function() { callback(); });
        async.series(fns);
      },
      function(callback) {
        put_cluster(conn1, [ { id: selfcheck1, port: noit1.get_api_port() },
                             { id: selfcheck2, port: noit2.get_api_port() } ], 0,
                    function(code, data) {
                      test.is(code, 204, "configure cluster");
                      callback();
                    });
      },
      function(callback) {
        put_cluster(conn2, [ { id: selfcheck1, port: noit1.get_api_port() },
                             { id: selfcheck2, port: noit2.get_api_port() } ], 1,
                    function(code, data) {
                      test.is(code, 204, "configure cluster");
                      callback();
                    });
      },
      function(callback) {
        check_check(test, conn1, check, 404, callback);
      },
      function(callback) {
        check_check(test, conn2, check, 404, callback);
      },
      function(callback) { put_check(conn1, check, 'plague',
        function(code, data) {
          test.is(code, 200, 'put plague check');
          callback();
        });
      },
      function(done) { noit2.wait_for_log(/plague/, 20000, function() {done();}) },
      function(callback) {
        check_check(test, conn1, check, 200, "active_on_cluster_node", true, callback);
      },
      function(callback) {
        check_check(test, conn2, check, 200, "active_on_cluster_node", false, callback);
      },
      function(callback) { noit1.pause(); callback(); },
      function(callback) { setTimeout(function() { callback(); }, 2000); },
      function(callback) {
        check_check(test, conn2, check, 200, "active_on_cluster_node", true, callback);
      },
      function(callback) { noit1.continue(); callback(); },
      function(callback) { setTimeout(function() { callback(); }, 1000); },
      function(callback) {
        check_check(test, conn1, check, 200, "active_on_cluster_node", true, callback);
      },
      function(callback) {
        check_check(test, conn2, check, 200, "active_on_cluster_node", false, callback);
      },
      function(callback) {
        check_delete(conn2, check, function(code, data) {
          test.is(code, 200, 'deleted from node 2');
          callback();
        });
      },
      function(callback) {
        check_check(test, conn2, check, 200, function(t,o) {
          t.ok(o.flags & 0x80, "check deleted");
        }, callback);
      },
      function(callback) { setTimeout(function() { callback(); }, 500); },
      function(callback) {
        check_check(test, conn1, check, 200, function(t,o) {
          t.ok(o.flags & 0x80, "check deleted");
        }, callback);
      },
      function(callback) { setTimeout(function() { callback(); }, 1500); },
      function(callback) {
        check_check(test, conn1, check, 404, callback);
      },
      function(callback) {
        check_check(test, conn2, check, 404, callback);
      },
      function(callback) { noit1.stop(); callback(); },
      function(callback) { noit2.stop(); callback(); },
    ]);
  };

  noit1.start(function(pid, port) {
    test.is(port, noit1.get_api_port(), 'API port matches');
    running++;
    complete();
  });

  noit2.start(function(pid, port) {
    test.is(port, noit2.get_api_port(), 'API port matches');
    running++;
    complete();
  });

}
